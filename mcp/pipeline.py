from troposphere.stepfunctions import StateMachine

from troposphere import (
    GetAtt,
    GetAZs,
    Join,
    Output,
    Parameter,
    Ref,
    Select,
    Tags,
    Template,
)

from troposphere.ecs import (
    Cluster,
    ContainerDefinition,
    NetworkConfiguration,
    PortMapping,
    RuntimePlatform,
    TaskDefinition,
    CapacityProviderStrategyItem,
    HealthCheck,
    Ulimit,
    EphemeralStorage,
    LogConfiguration
)
from troposphere.iam import (
    PolicyType,
    Role
)
from troposphere.ec2 import (
    SecurityGroup,
    SecurityGroupIngress
)
from troposphere.ec2 import (
    EIP,
    VPC,
    Instance,
    InternetGateway,
    NetworkAcl,
    NetworkAclEntry,
    NetworkInterfaceProperty,
    PortRange,
    Route,
    RouteTable,
    SecurityGroup,
    SecurityGroupIngress,
    SecurityGroupRule,
    Subnet,
    SubnetNetworkAclAssociation,
    SubnetRouteTableAssociation,
    VPCGatewayAttachment,
    VPCEndpoint,
)

from workflow import get_workflow

t = Template()
t.set_version("2010-09-09")
t.set_transform('AWS::Serverless-2016-10-31')

vpc = t.add_resource(
    VPC(
        "VPC",
        CidrBlock = "10.192.0.0/16",
        EnableDnsHostnames=True,
        EnableDnsSupport=True,
        Tags=Tags(Name="VPC - Malware Classification", CreatedBy='malware-classification-pipeline'),
    )
)

publicsubnet1 = t.add_resource(
    Subnet(
        "PublicSubnet1",
        CidrBlock="10.192.10.0/24",
        VpcId=Ref(vpc),
        AvailabilityZone=Select(0, GetAZs('')),
        MapPublicIpOnLaunch=False,
        Tags=Tags(Name="PublicSubnet1 - Malware Classification", CreatedBy='malware-classification-pipeline'),
    )
)

publicsubnet2 = t.add_resource(
    Subnet(
        "PublicSubnet2",
        CidrBlock="10.192.11.0/24",
        VpcId=Ref(vpc),
        AvailabilityZone=Select(1, GetAZs('')),
        MapPublicIpOnLaunch=False,
        Tags=Tags(Name="PublicSubnet2 - Malware Classification", CreatedBy='malware-classification-pipeline'),
    )
)

publicroutetable1=t.add_resource(
    RouteTable(
        "PublicRouteTable1",
        VpcId=Ref(vpc),
        Tags=Tags(Name="PublicRouteTable1 - Malware Classification", CreatedBy='malware-classification-pipeline'),
    )
)

publicroutetable2=t.add_resource(
    RouteTable(
        "PublicRouteTable2",
        VpcId=Ref(vpc),
        Tags=Tags(Name="PublicRouteTable2 - Malware Classification", CreatedBy='malware-classification-pipeline'),
    )
)

internetgateway=t.add_resource(
    InternetGateway(
        "InternetGateway",
        Tags=Tags(Name="InternetGateway - Malware Classification", CreatedBy='malware-classification-pipeline'),
    )
)

gatewayAttachment = t.add_resource(
    VPCGatewayAttachment(
        "AttachGateway", VpcId=Ref(vpc), InternetGatewayId=Ref(internetgateway)
    )
)

routepublic1 = t.add_resource(
    Route(
        "RoutePublic1",
        DependsOn="AttachGateway",
        GatewayId=Ref("InternetGateway"),
        DestinationCidrBlock="0.0.0.0/0",
        RouteTableId=Ref(publicroutetable1),
    )
)

routepublic2 = t.add_resource(
    Route(
        "RoutePublic2",
        DependsOn="AttachGateway",
        GatewayId=Ref("InternetGateway"),
        DestinationCidrBlock="0.0.0.0/0",
        RouteTableId=Ref(publicroutetable2),
    )
)

pubroutetableassociation1=t.add_resource(
    SubnetRouteTableAssociation(
        "PublicSubnet1RouteTableAssociation",
        RouteTableId=Ref(publicroutetable1),
        SubnetId=Ref(publicsubnet1)
    )
)

pubroutetableassociation2=t.add_resource(
    SubnetRouteTableAssociation(
        "PublicSubnet2RouteTableAssociation",
        RouteTableId=Ref(publicroutetable2),
        SubnetId=Ref(publicsubnet2),
    )
)

clustersecuritygroup=t.add_resource(
    SecurityGroup(
        "ClusterSecurityGroup",
        GroupDescription="Cluster default security group",
        VpcId=Ref(vpc),
        Tags=Tags(CreatedBy='malware-classification-pipeline'),
    )
)

clustersecuritygroupingress=t.add_resource(
    SecurityGroupIngress(
        "ClusterSecurityGroupIngress",
        GroupId=Ref(clustersecuritygroup),
        IpProtocol="tcp",
        FromPort=8000,
        ToPort=8001,
        SourceSecurityGroupId=Ref(clustersecuritygroup),
        DependsOn="ClusterSecurityGroup",
    )
)


cluster=t.add_resource(
    Cluster(
        "MalwareClassificationCluster",
        ClusterName="malware_classification_cluster",
        CapacityProviders=["FARGATE", "FARGATE_SPOT"],
        DefaultCapacityProviderStrategy=[
            CapacityProviderStrategyItem(
                Base=2,
                CapacityProvider="FARGATE",
                Weight=1
            ),
            CapacityProviderStrategyItem(
                Base=0,
                CapacityProvider="FARGATE_SPOT",
                Weight=3
            )
        ],
        Tags=Tags(CreatedBy='malware-classification-pipeline'),
    )
)

daskexecutionrole=t.add_resource(
    Role(
        "DaskExecutionRole",
        AssumeRolePolicyDocument={
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": "sts:AssumeRole",
                    "Principal": {"Service": ["ecs-tasks.amazonaws.com"]},
                    "Effect": "Allow",
                }
            ],
        },
        Path="/"
    )
)

dasktaskrole=t.add_resource(
    Role(
        "DaskTaskRole",
        AssumeRolePolicyDocument={
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": "sts:AssumeRole",
                    "Principal": {"Service": ["ecs-tasks.amazonaws.com", "states.amazonaws.com"]},
                    "Effect": "Allow",
                },
            ],
        },
        Path="/"
    )
)

daskexecutionpolicy=t.add_resource(
    PolicyType(
        "DaskExecutionPolicy",
        PolicyName="DaskExecutionPolicy",
        PolicyDocument={
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": [
                        "ecr:GetAuthorizationToken",
                        "ecr:BatchCheckLayerAvailability",
                        "ecr:GetDownloadUrlForLayer",
                        "ecr:BatchGetImage"
                    ],
                    "Resource": ["*"],
                    "Effect": "Allow",
                    "Sid": "AllowPull",
                },
                {
                    "Action": [
                        "logs:CreateLogGroup",
                        "logs:CreateLogStream",
                        "logs:PutLogEvents"
                    ],
                    "Resource": ["*"],
                    "Effect": "Allow",
                    "Sid": "AllowLogs",
                },
            ],
        },
        Roles=[Ref("DaskExecutionRole")],
    )
)

daskpolicy=t.add_resource(
    PolicyType(
        "DaskPolicy",
        PolicyName="DaskPolicy",
        PolicyDocument={
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": [
                        "ecs:*",
                        "iam:PassRole"
                    ],
                    "Resource": ["*"],
                    "Effect": "Allow",
                    "Sid": "AllowRun",
                },
                {
                    "Action": [
                        "logs:CreateLogGroup",
                        "logs:CreateLogStream",
                        "logs:PutLogEvents"
                    ],
                    "Resource": ["*"],
                    "Effect": "Allow",
                    "Sid": "AllowLogs",
                },
            ],
        },
        Roles=[Ref("DaskTaskRole")],
    )
)

dasktaskdefinition=t.add_resource(
    TaskDefinition(
        "DaskTaskDefinition",
        RequiresCompatibilities=["FARGATE"],
        RuntimePlatform=RuntimePlatform(
            CpuArchitecture="X86_64",
            OperatingSystemFamily="LINUX",
        ),
        Cpu="2048",
        Memory="4096",
        EphemeralStorage=EphemeralStorage(SizeInGiB=60),
        NetworkMode="awsvpc",
        Family="dask-family",
        ExecutionRoleArn=GetAtt(daskexecutionrole, "Arn"),
        TaskRoleArn=GetAtt(dasktaskrole, "Arn"),
        ContainerDefinitions=[
            ContainerDefinition(
                Name="dask", 
                Essential=True,
                HealthCheck=HealthCheck(
                    Command=[ "CMD-SHELL", "pidof tini || exit 1" ],
                    Interval=15,
                    Retries=10,
                    StartPeriod=30,
                    Timeout=10,
                ),
                Image=Join(".", [Ref("AWS::AccountId"),"dkr","ecr",Ref("AWS::Region"),"amazonaws","com/malware-classification-repository:latest"]),
                PortMappings=[
                    PortMapping(ContainerPort=8000, HostPort=8000, Protocol="tcp"),
                    PortMapping(ContainerPort=8001, HostPort=8001, Protocol="tcp"),
                ],
                Ulimits=[
                    Ulimit(HardLimit=102400, SoftLimit=102400, Name="nofile")
                ],
                LogConfiguration=LogConfiguration(
                    LogDriver="awslogs",
                    Options={
                        "awslogs-group": "malware-classification-pipeline-cluster",
                        "awslogs-region": Ref("AWS::Region"),
                        "awslogs-create-group": "true",
                        "awslogs-stream-prefix": "dask-"
                    }
                )
            )
        ],
        Tags=Tags(CreatedBy='malware-classification-pipeline'),
    )
)

pipeline=t.add_resource(StateMachine(
    'Pipeline',
    StateMachineName='malware-classification-pipeline',
    StateMachineType='STANDARD',
    RoleArn=GetAtt(dasktaskrole, "Arn"),
    DefinitionString=get_workflow(),
    DefinitionSubstitutions={
        "cluster": Ref(cluster),
        "subnet1": Ref(publicsubnet1),
        "subnet2": Ref(publicsubnet2),
        "securitygroup": Ref(clustersecuritygroup),
        "taskdefinition": Ref(dasktaskdefinition),
    }
))

with open('pipeline.yml', 'w') as f:
    f.write(t.to_yaml())


