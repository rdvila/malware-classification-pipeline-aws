import json

from troposphere.stepfunctions import StateMachine

from troposphere import (
    GetAtt,
    GetAZs,
    Join,
    Output,
    Parameter,
    Ref,
    Select,
    Tags,
    Template,
)

from troposphere.iam import (
    Policy,
    Role
)

workflowdefinition={
    "StartAt": "skip preprocessing?",
    "States": {
        "skip preprocessing?": {
            "Type": "Choice",
            "Default": "skip hyperparameter tuning?",
            "Choices": [
                {
                    "Variable": "$.Experiment.Preprocessing",
                    "IsPresent": True,
                    "Next": "start preprocessing"
                }
            ]

        },
        "skip hyperparameter tuning?": {
            "Type": "Choice",
            "Default": "skip training?",
            "Choices": [
                {
                    "Variable": "$.Experiment.HyperparameterTuning",
                    "IsPresent": True,
                    "Next": "start hyperparameter tuning"
                }
            ]

        },
        "skip training?": {
            "Type": "Choice",
            "Default": "skip test?",
            "Choices": [
                {
                    "Variable": "$.Experiment.Training",
                    "IsPresent": True,
                    "Next": "start training"
                }
            ]

        },
        "skip test?": {
            "Type": "Choice",
            "Default": "skip deployment?",
            "Choices": [
                {
                    "Variable": "$.Experiment.Test",
                    "IsPresent": True,
                    "Next": "start test"
                }
            ]

        },
        "skip deployment?": {
            "Type": "Choice",
            "Default": "success",
            "Choices": [
                {
                    "Variable": "$.Experiment.Deployment",
                    "IsPresent": True,
                    "Next": "start deployment"
                }
            ]

        },
        "start preprocessing":{
            "Type": "Map",
            "ItemsPath": "$.Experiment.Preprocessing",
            "MaxConcurrency": 1,
            "Parameters": {
                "AccountId": "${AccountId}",
                "Region": "${Region}",
                "RoleArn": "${RoleArn}",
                "Id.$": "$.Experiment.Name",
                "ExperimentName.$": "$$.Map.Item.Value.Name",
                "Image.$": "$$.Map.Item.Value.Image",
                "InstanceCount.$": "$$.Map.Item.Value.InstanceCount",
                "InstanceType.$": "$$.Map.Item.Value.InstanceType",
                "VolumeSizeInGB.$": "$$.Map.Item.Value.VolumeSizeInGB",
                "Bucket.$": "$$.Map.Item.Value.Bucket",
                "Prefix.$": "$$.Map.Item.Value.Prefix",
                "ContainerArguments.$": "$$.Map.Item.Value.ContainerArguments",
                "MaxRuntimeInSeconds.$": "$$.Map.Item.Value.MaxRuntimeInSeconds",
                "ExecutionName.$": "$$.Execution.Name"
            },
            "Iterator": {
                "StartAt": "preprocessing",
                "States": {
                    "preprocessing": {
                        "Type": "Task",
                        "Resource": "arn:aws:states:::sagemaker:createProcessingJob.sync",
                        "Parameters": {
                            "AppSpecification": {
                                "ImageUri.$": "States.Format('{}.dkr.ecr.{}.amazonaws.com/{}', $.AccountId, $.Region, $.Image)",
                                "ContainerArguments.$": "$.ContainerArguments"
                            },
                            "ProcessingResources": {
                                "ClusterConfig": {
                                    "InstanceCount.$": "$.InstanceCount",
                                    "InstanceType.$": "$.InstanceType",
                                    "VolumeSizeInGB.$": "$.VolumeSizeInGB"
                                }
                            },
                            "RoleArn.$": "$.RoleArn",
                            "ProcessingInputs": [
                                {
                                    "InputName": "input",
                                    "S3Input": {
                                        "LocalPath": "/opt/ml/processing/data/",
                                        "S3CompressionType": "None",
                                        "S3DataType": "S3Prefix",
                                        "S3InputMode": "File",
                                        "S3DataDistributionType": "FullyReplicated",
                                        "S3Uri.$": "States.Format('s3://{}/{}', $.Bucket, $.Prefix)"
                                    }
                                }
                            ],
                            "ProcessingJobName.$": "States.Format('{}-{}-{}', $.ExecutionName, $.Id, $.ExperimentName)",
                            "ProcessingOutputConfig": {
                                "Outputs": [
                                    {
                                        "OutputName": "output",
                                        "S3Output": {
                                            "LocalPath": "/opt/ml/processing/output/",
                                            "S3UploadMode": "EndOfJob",
                                            "S3Uri.$": "States.Format('s3://{}/preprocessing/{}/{}', $.Bucket, $.Id, $.ExperimentName)"
                                        }
                                    }
                                ]
                            },
                            "StoppingCondition": {
                                "MaxRuntimeInSeconds.$": "$.MaxRuntimeInSeconds"
                            },
                        },
                        "End": True
                    }
                }
            },
            "ResultSelector": {
              "Status": "OK"
            },
            "ResultPath": "$.PreprocessingExecution",
            "Next": "skip hyperparameter tuning?"
        },
        "start hyperparameter tuning":{
            "Type": "Pass",
            "Next": "skip training?"
        },
        "start training":{
            "Type": "Pass",
            "Next": "skip test?"
        },
        "start test":{
            "Type": "Pass",
            "Next": "skip deployment?"
        },
        "start deployment":{
            "Type": "Pass",
            "Next": "success"
        },
        "success": {
            "Type": "Succeed"
        }
    }
}

t = Template()
t.set_version("2010-09-09")
t.set_transform('AWS::Serverless-2016-10-31')

pipelinerole=t.add_resource(
    Role(
        "PipelineRole",
        AssumeRolePolicyDocument={
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": "sts:AssumeRole",
                    "Principal": {"Service": ["states.amazonaws.com"]},
                    "Effect": "Allow",
                },
            ],
        },
        Path="/",
        Policies=[
            Policy(
                PolicyName="PipelinePolicy",
                PolicyDocument={
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Action": [
                                "sagemaker:*",
                                "events:PutTargets",
                                "events:PutRule",
                                "events:DescribeRule",
                                "iam:PassRole"
                            ],
                            "Resource": ["*"],
                            "Effect": "Allow",
                            "Sid": "AllowRun",
                        },
                        {
                            "Action": [
                                "logs:CreateLogGroup",
                                "logs:CreateLogStream",
                                "logs:PutLogEvents"
                            ],
                            "Resource": ["*"],
                            "Effect": "Allow",
                            "Sid": "AllowLogs",
                        },
                    ],
                },
            )
        ]
    )
)

sagemakerexecutionrole=t.add_resource(
    Role(
        "SageMakerExecutionRole",
        AssumeRolePolicyDocument={
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": "sts:AssumeRole",
                    "Principal": {"Service": ["sagemaker.amazonaws.com"]},
                    "Effect": "Allow",
                },
            ],
        },
        Path="/",
        ManagedPolicyArns=[
            "arn:aws:iam::aws:policy/AmazonSageMakerFullAccess",  # NOQA
        ],
        Policies=[
            Policy(
                PolicyName="PipelinePolicy",
                PolicyDocument={
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Action": [
                                "s3:GetObject",
                                "s3:PutObject",
                                "s3:DeleteObject",
                                "s3:ListBucket",
                                "log:*"
                            ],
                            "Resource": ["*"],
                            "Effect": "Allow",
                            "Sid": "AllowS3AndLogs",
                        },
                    ],
                },
            )
        ],
    )
)

pipeline=t.add_resource(
    StateMachine(
        'Pipeline',
        StateMachineName='malware-classification-pipeline',
        StateMachineType='STANDARD',
        RoleArn=GetAtt(pipelinerole, "Arn"),
        DefinitionString=json.dumps(workflowdefinition),
        DefinitionSubstitutions={
            "AccountId": Ref("AWS::AccountId"),
            "Region": Ref("AWS::Region"),
            "RoleArn": GetAtt(sagemakerexecutionrole, "Arn")
        }
    )
)

with open('pipeline.yml', 'w') as f:
    f.write(t.to_yaml())

